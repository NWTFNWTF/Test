<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Plan2Nav3D — Minimal Viewer</title>
  <style>
    html, body { height: 100%; margin: 0; background: #111; color: #eee; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #ui { position: fixed; top: 10px; left: 10px; z-index: 10; display:flex; gap:8px; align-items:center; }
    button, label { background:#1f1f1f; color:#eee; border:1px solid #2f2f2f; padding:8px 12px; border-radius:10px; cursor:pointer; }
    button:hover, label:hover { background:#2a2a2a; }
    #drop { position: fixed; inset:0; outline: 2px dashed #444; outline-offset: -12px; display:none; place-items:center; color:#bbb; font-size:14px; }
    #msg { position: fixed; bottom: 12px; left: 12px; right: 12px; color:#ccc; font-size: 13px; }
    #canvas { width: 100vw; height: 100vh; display:block; }
    input[type="file"] { display: none; }
  </style>
</head>
<body>
  <div id="ui">
    <button id="demoBtn">Demo</button>
    <button id="resetBtn">Reset camera</button>
    <label for="file">Apri .glb</label>
    <input id="file" type="file" accept=".glb,model/gltf-binary" />
  </div>
  <div id="drop">Rilascia qui un file .glb</div>
  <div id="msg">Pronto. Carica un file .glb con il bottone o trascinalo sulla finestra. Se non hai un modello, premi “Demo”.</div>
  <canvas id="canvas"></canvas>

  <!-- Three.js from a reliable CDN -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.1/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.1/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.160.1/examples/jsm/loaders/GLTFLoader.js';

    // --- Basic scene ---
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 2000);
    camera.position.set(2.5, 2, 3);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.9);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5, 10, 7);
    scene.add(dir);

    // Grid/floor (togglable if needed)
    const grid = new THREE.GridHelper(10, 10, 0x333333, 0x222222);
    grid.position.y = 0;
    scene.add(grid);

    let currentRoot = null;
    const loader = new GLTFLoader();

    function showMessage(text, isError=false) {
      const el = document.getElementById('msg');
      el.textContent = text;
      el.style.color = isError ? '#ff7b7b' : '#ccc';
    }

    function fitCameraToObject(object) {
      const box = new THREE.Box3().setFromObject(object);
      const size = new THREE.Vector3();
      const center = new THREE.Vector3();
      box.getSize(size);
      box.getCenter(center);

      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI / 180);
      let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));

      cameraZ *= 1.5; // padding
      camera.position.set(center.x + cameraZ, center.y + cameraZ * 0.6, center.z + cameraZ);
      camera.near = cameraZ / 100;
      camera.far = cameraZ * 400;
      camera.updateProjectionMatrix();

      controls.target.copy(center);
      controls.update();
    }

    function clearModel() {
      if (currentRoot) {
        scene.remove(currentRoot);
        currentRoot.traverse((obj)=>{
          if (obj.isMesh) {
            obj.geometry?.dispose();
            if (obj.material) {
              if (Array.isArray(obj.material)) obj.material.forEach(m=>m.dispose());
              else obj.material.dispose();
            }
          }
        });
        currentRoot = null;
      }
    }

    async function loadGLBFromBlob(blob) {
      try {
        showMessage('Caricamento modello...');
        clearModel();
        const arrayBuffer = await blob.arrayBuffer();
        const gltf = await new Promise((resolve, reject) => {
          loader.parse(arrayBuffer, '', resolve, reject);
        });
        currentRoot = gltf.scene || gltf.scenes?.[0];
        if (!currentRoot) throw new Error('GLB privo di scena');
        scene.add(currentRoot);
        fitCameraToObject(currentRoot);
        showMessage('Modello caricato.');
      } catch (err) {
        console.error(err);
        showMessage('Errore nel caricamento: ' + (err?.message || err), true);
      }
    }

    // Drag & drop
    const drop = document.getElementById('drop');
    ['dragenter', 'dragover'].forEach(evt => {
      window.addEventListener(evt, (e)=>{ e.preventDefault(); drop.style.display='grid'; });
    });
    ['dragleave', 'drop'].forEach(evt => {
      window.addEventListener(evt, (e)=>{ e.preventDefault(); drop.style.display='none'; });
    });
    window.addEventListener('drop', (e)=>{
      const f = e.dataTransfer.files?.[0];
      if (f) loadGLBFromBlob(f);
    });

    // File input
    document.getElementById('file').addEventListener('change', (e)=>{
      const f = e.target.files?.[0];
      if (f) loadGLBFromBlob(f);
      e.target.value = '';
    });

    // Demo: create a simple house-like cube so it always works offline
    document.getElementById('demoBtn').addEventListener('click', ()=>{
      showMessage('Demo pronta.');
      clearModel();
      const group = new THREE.Group();

      const base = new THREE.Mesh(
        new THREE.BoxGeometry(2, 1, 2),
        new THREE.MeshStandardMaterial({ metalness:0.0, roughness:0.9 })
      );
      base.position.y = 0.5;
      group.add(base);

      const roof = new THREE.Mesh(
        new THREE.ConeGeometry(1.4, 0.8, 4),
        new THREE.MeshStandardMaterial({ metalness:0.0, roughness:0.7 })
      );
      roof.position.y = 1.4;
      roof.rotation.y = Math.PI/4;
      group.add(roof);

      scene.add(group);
      currentRoot = group;
      fitCameraToObject(group);
    });

    // Reset camera
    document.getElementById('resetBtn').addEventListener('click', ()=>{
      if (currentRoot) fitCameraToObject(currentRoot);
      else {
        camera.position.set(2.5, 2, 3);
        controls.target.set(0,0,0);
        controls.update();
      }
    });

    // Resize
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Render loop
    (function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    })();
  </script>
</body>
</html>
