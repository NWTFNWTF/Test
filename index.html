<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Plan2Nav3D — Fallback (no module)</title>
  <style>
    html, body { height: 100%; margin: 0; background: #111; color: #eee; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #ui { position: fixed; top: 10px; left: 10px; z-index: 10; display:flex; gap:8px; align-items:center; }
    button, label { background:#1f1f1f; color:#eee; border:1px solid #2f2f2f; padding:8px 12px; border-radius:10px; cursor:pointer; }
    button:hover, label:hover { background:#2a2a2a; }
    #drop { position: fixed; inset:0; outline: 2px dashed #444; outline-offset: -12px; display:none; place-items:center; color:#bbb; font-size:14px; }
    #msg { position: fixed; bottom: 12px; left: 12px; right: 12px; color:#ccc; font-size: 13px; }
    #canvas { width: 100vw; height: 100vh; display:block; }
    input[type="file"] { display: none; }
  </style>
</head>
<body>
  <div id="ui">
    <button id="demoBtn">Demo</button>
    <button id="resetBtn">Reset camera</button>
    <label for="file">Apri .glb</label>
    <input id="file" type="file" accept=".glb,model/gltf-binary" />
  </div>
  <div id="drop">Rilascia qui un file .glb</div>
  <div id="msg">Pronto (fallback). Se non hai un modello, premi “Demo”.</div>
  <canvas id="canvas"></canvas>

  <!-- Legacy global scripts (no type=module). Use matching versions. -->
  <script src="https://unpkg.com/three@0.160.1/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.160.1/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/three@0.160.1/examples/js/loaders/GLTFLoader.js"></script>

  <script>
    // Basic scene
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 2000);
    camera.position.set(2.5, 2, 3);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.9);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5, 10, 7);
    scene.add(dir);

    const grid = new THREE.GridHelper(10, 10, 0x333333, 0x222222);
    grid.position.y = 0;
    scene.add(grid);

    let currentRoot = null;
    const loader = new THREE.GLTFLoader();

    function showMessage(text, isError){
      const el = document.getElementById('msg');
      el.textContent = text;
      el.style.color = isError ? '#ff7b7b' : '#ccc';
    }

    function fitCameraToObject(object) {
      const box = new THREE.Box3().setFromObject(object);
      const size = new THREE.Vector3();
      const center = new THREE.Vector3();
      box.getSize(size);
      box.getCenter(center);

      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI / 180);
      let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
      cameraZ *= 1.5;

      camera.position.set(center.x + cameraZ, center.y + cameraZ * 0.6, center.z + cameraZ);
      camera.near = cameraZ / 100;
      camera.far = cameraZ * 400;
      camera.updateProjectionMatrix();
      controls.target.copy(center);
      controls.update();
    }

    function clearModel(){
      if (!currentRoot) return;
      scene.remove(currentRoot);
      currentRoot.traverse(function(obj){
        if (obj.isMesh){
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material){
            if (Array.isArray(obj.material)) obj.material.forEach(m=>m.dispose());
            else obj.material.dispose();
          }
        }
      });
      currentRoot = null;
    }

    function loadGLBFromBlob(blob){
      showMessage('Caricamento modello...');
      clearModel();
      const reader = new FileReader();
      reader.onload = function(){
        const arrayBuffer = reader.result;
        loader.parse(arrayBuffer, '', function(gltf){
          currentRoot = gltf.scene || (gltf.scenes && gltf.scenes[0]);
          if (!currentRoot) { showMessage('GLB privo di scena', true); return; }
          scene.add(currentRoot);
          fitCameraToObject(currentRoot);
          showMessage('Modello caricato.');
        }, function(err){
          console.error(err);
          showMessage('Errore nel caricamento: ' + (err && err.message ? err.message : err), true);
        });
      };
      reader.onerror = function(e){ showMessage('Errore lettura file.', true); };
      reader.readAsArrayBuffer(blob);
    }

    const drop = document.getElementById('drop');
    ['dragenter','dragover'].forEach(function(evt){
      window.addEventListener(evt, function(e){ e.preventDefault(); drop.style.display='grid'; });
    });
    ['dragleave','drop'].forEach(function(evt){
      window.addEventListener(evt, function(e){ e.preventDefault(); drop.style.display='none'; });
    });
    window.addEventListener('drop', function(e){
      const f = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
      if (f) loadGLBFromBlob(f);
    });

    document.getElementById('file').addEventListener('change', function(e){
      const f = e.target.files && e.target.files[0];
      if (f) loadGLBFromBlob(f);
      e.target.value = '';
    });

    document.getElementById('demoBtn').addEventListener('click', function(){
      showMessage('Demo pronta.');
      clearModel();
      const group = new THREE.Group();
      const base = new THREE.Mesh(
        new THREE.BoxGeometry(2, 1, 2),
        new THREE.MeshStandardMaterial({ metalness:0.0, roughness:0.9 })
      );
      base.position.y = 0.5;
      group.add(base);
      const roof = new THREE.Mesh(
        new THREE.ConeGeometry(1.4, 0.8, 4),
        new THREE.MeshStandardMaterial({ metalness:0.0, roughness:0.7 })
      );
      roof.position.y = 1.4;
      roof.rotation.y = Math.PI/4;
      group.add(roof);
      scene.add(group);
      currentRoot = group;
      fitCameraToObject(group);
    });

    document.getElementById('resetBtn').addEventListener('click', function(){
      if (currentRoot) fitCameraToObject(currentRoot);
      else {
        camera.position.set(2.5, 2, 3);
        controls.target.set(0,0,0);
        controls.update();
      }
    });

    window.addEventListener('resize', function(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    (function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    })();
  </script>
</body>
</html>
