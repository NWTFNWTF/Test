<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>Plan2Nav3D – MVP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0e0f12; --panel:#16181d; --text:#e7eaee; --muted:#8a93a5; --accent:#5ee1a7; }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;}
    #app{display:grid;grid-template-columns:320px 1fr;height:100%;}
    #ui{background:var(--panel);border-right:1px solid #1f232b;padding:16px 14px;overflow:auto;}
    h1{font-size:16px;margin:0 0 12px 0;letter-spacing:.2px}
    .muted{color:var(--muted)}
    .group{margin:14px 0 18px;border:1px solid #242832;border-radius:10px;padding:12px}
    label{display:flex;align-items:center;justify-content:space-between;margin:8px 0}
    input[type="number"]{width:110px;background:#0f1116;color:var(--text);border:1px solid #2a2f3a;border-radius:8px;padding:6px 8px}
    input[type="file"]{width:100%}
    button{cursor:pointer;border:0;background:#1e232d;color:var(--text);border-radius:10px;padding:10px 12px;margin-right:8px}
    button.primary{background:linear-gradient(135deg,#12d19b,#36a9e1);color:#041016}
    button:disabled{opacity:.6;cursor:not-allowed}
    #canvas-wrap{position:relative}
    #hud{position:absolute;left:12px;bottom:12px;background:#0f1116aa;border:1px solid #242832;border-radius:10px;color:var(--text);padding:10px 12px;backdrop-filter: blur(6px)}
    #hud small{color:var(--muted)}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    .pill{background:#0f1116;border:1px solid #242832;border-radius:999px;padding:6px 10px;color:var(--muted)}
    a{color:var(--accent);text-decoration:none}
    .k{display:inline-block;min-width:18px;text-align:center;border:1px solid #2a2f3a;border-radius:4px;padding:0 4px;margin:0 3px;background:#0f1116}
  </style>
</head>
<body>
<div id="app">
  <div id="ui">
    <h1>Plan2Nav3D <span class="muted">– MVP</span></h1>
    <div class="group">
      <label>Carica planimetria SVG
        <input id="file" type="file" accept=".svg,image/svg+xml">
      </label>
      <div class="row" style="margin-top:8px">
        <button id="demo">Demo</button>
        <button id="reset">Reset camera</button>
        <button id="mode">Modalità: Orbit</button>
      </div>
      <p class="muted" style="margin-top:8px">
        Convenzioni SVG: <code>&lt;line class="wall" data-thickness="120"&gt;</code>,
        <code>&lt;line class="door"&gt;</code>, <code>&lt;line class="window"&gt;</code>.
      </p>
    </div>

    <div class="group">
      <label>Unità SVG per metro (es. mm → <b>1000</b>)
        <input id="unitsPerMeter" type="number" step="1" min="1" value="1000">
      </label>
      <label>Altezza pareti (m)
        <input id="wallH" type="number" step="0.1" min="1" value="2.8">
      </label>
      <label>Altezza porta (m)
        <input id="doorH" type="number" step="0.05" min="1" value="2.1">
      </label>
      <label>Quota davanzale (m)
        <input id="sillH" type="number" step="0.05" min="0" value="0.9">
      </label>
      <label>Altezza finestra (m)
        <input id="winH" type="number" step="0.05" min="0.2" value="1.2">
      </label>
    </div>

    <div class="group">
      <div class="row">
        <span class="pill">Mouse: trascina per ruotare</span>
        <span class="pill">Rotella: zoom</span>
        <span class="pill">Maiusc: pan</span>
      </div>
      <p style="margin:8px 0 0"><b>First person</b>: clic canvas → <span class="k">W</span><span class="k">A</span><span class="k">S</span><span class="k">D</span>, <span class="k">ESC</span> per uscire.</p>
    </div>

    <div class="group">
      <p style="margin:0 0 6px"><b>Limitazioni MVP</b></p>
      <ul class="muted" style="margin:0 0 0 18px;padding:0">
        <li>Richiede planimetrie SVG con linee (no raster).</li>
        <li>Niente CSG: aperture ricomposte per segmenti (leggero/robusto).</li>
        <li>Spessori da <code>data-thickness</code> (mm) su ciascuna parete.</li>
      </ul>
    </div>

    <p class="muted">Vuoi import DXF/IFC o riconoscere da PNG? Si può estendere (parser DXF o tracciamento guidato in canvas).</p>
  </div>

  <div id="canvas-wrap">
    <canvas id="c"></canvas>
    <div id="hud">
      <div><b>Stato:</b> <span id="status">Pronto</span></div>
      <small id="meta"></small>
    </div>
  </div>
</div>

<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
  import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';
  import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/PointerLockControls.js';

  // ---------- DOM ----------
  const fileEl = document.getElementById('file');
  const demoBtn = document.getElementById('demo');
  const resetBtn = document.getElementById('reset');
  const modeBtn = document.getElementById('mode');
  const statusEl = document.getElementById('status');
  const metaEl = document.getElementById('meta');
  const unitsEl = document.getElementById('unitsPerMeter');
  const wallHEl = document.getElementById('wallH');
  const doorHEl = document.getElementById('doorH');
  const sillHEl = document.getElementById('sillH');
  const winHEl  = document.getElementById('winH');

  const canvas = document.getElementById('c');

  // ---------- Three.js base ----------
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
  const scene = new THREE.Scene();
  scene.background = null;

  const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 2000);
  camera.position.set(3, 3, 3);

  const orbit = new OrbitControls(camera, renderer.domElement);
  orbit.enableDamping = true;
  orbit.dampingFactor = 0.08;
  orbit.screenSpacePanning = true;
  orbit.maxPolarAngle = Math.PI * 0.49;

  const fp = new PointerLockControls(camera, renderer.domElement);
  let useFP = false;
  modeBtn.addEventListener('click', () => {
    useFP = !useFP;
    modeBtn.textContent = `Modalità: ${useFP ? 'First person' : 'Orbit'}`;
    if (!useFP) {
      try { document.exitPointerLock?.(); } catch {}
    }
  });
  canvas.addEventListener('click', () => {
    if (useFP) fp.lock();
  });

  // WASD
  const vel = new THREE.Vector3();
  const keys = {};
  window.addEventListener('keydown', e => keys[e.code]=true);
  window.addEventListener('keyup',   e => keys[e.code]=false);

  // Lights
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.9);
  hemi.position.set(0, 1, 0);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(5, 8, 4);
  scene.add(dir);

  // Floor grid (helper)
  const grid = new THREE.GridHelper(100, 100, 0x777777, 0x333333);
  grid.position.y = 0.001; // just above ground to avoid z-fighting
  scene.add(grid);

  // Resize
  function onResize(){
    const rect = canvas.parentElement.getBoundingClientRect();
    renderer.setSize(rect.width, rect.height, false);
    camera.aspect = rect.width / rect.height;
    camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', onResize);
  onResize();

  // Animation
  const clock = new THREE.Clock();
  function animate(){
    const dt = Math.min(0.05, clock.getDelta());
    if (useFP && fp.isLocked){
      const speed = 2.0; // m/s
      vel.set(0,0,0);
      const forward = new THREE.Vector3();
      fp.getDirection(forward);
      forward.y = 0; forward.normalize();
      const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).multiplyScalar(-1);

      if (keys['KeyW']) vel.add(forward);
      if (keys['KeyS']) vel.add(forward.clone().multiplyScalar(-1));
      if (keys['KeyA']) vel.add(right.clone().multiplyScalar(-1));
      if (keys['KeyD']) vel.add(right);

      if (vel.lengthSq()>0) {
        vel.normalize().multiplyScalar(speed*dt);
        camera.position.add(vel);
      }
    } else {
      orbit.update();
    }
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }
  animate();

  // ---------- Plan → 3D ----------
  const materials = {
    wall:  new THREE.MeshStandardMaterial({ color: 0xf3f5f8, metalness:0.0, roughness:0.9 }),
    floor: new THREE.MeshStandardMaterial({ color: 0x777b84, metalness:0.0, roughness:0.95 }),
    door:  new THREE.MeshStandardMaterial({ color: 0x7a5a3a, metalness:0.1, roughness:0.8 }),
    glass: new THREE.MeshPhysicalMaterial({ color:0x99c6ff, metalness:0.0, roughness:0.2, transmission:0.9, thickness:0.02, transparent:true, opacity:0.9 })
  };

  let currentGroup = null;

  function resetScene(){
    if (currentGroup) scene.remove(currentGroup);
    currentGroup = new THREE.Group();
    scene.add(currentGroup);
  }

  function svgToPlan(svgText){
    const parser = new DOMParser();
    const doc = parser.parseFromString(svgText, "image/svg+xml");
    const lines = Array.from(doc.querySelectorAll('line'));
    const walls = [];
    const doors = [];
    const wins  = [];

    for (const ln of lines){
      const cls = (ln.getAttribute('class')||'').trim();
      const x1 = parseFloat(ln.getAttribute('x1')||'0');
      const y1 = parseFloat(ln.getAttribute('y1')||'0');
      const x2 = parseFloat(ln.getAttribute('x2')||'0');
      const y2 = parseFloat(ln.getAttribute('y2')||'0');
      const L  = Math.hypot(x2-x1, y2-y1);
      if (!isFinite(L) || L<=0.0001) continue;

      if (cls.includes('wall')){
        const tmm = parseFloat(ln.getAttribute('data-thickness')||'120'); // mm default
        walls.push({ x1,y1,x2,y2, thicknessMM:tmm });
      } else if (cls.includes('door')){
        doors.push({ x1,y1,x2,y2, width:L }); // width in SVG units
      } else if (cls.includes('window')){
        wins.push({ x1,y1,x2,y2, width:L });
      }
    }
    return { walls, doors, wins, viewBox: doc.documentElement.getAttribute('viewBox')||null };
  }

  function build3D(plan, cfg){
    resetScene();

    // Bounds to size floor
    const pts = [];
    plan.walls.forEach(w => { pts.push([w.x1,w.y1],[w.x2,w.y2]); });

    // Convert SVG units → meters
    const S = 1 / cfg.unitsPerMeter; // meters per SVG unit
    function to3(x,y){ // SVG y→ 3D z (flipped)
      return new THREE.Vector3(x*S, 0, -y*S);
    }

    // Build floor (bounding box + margin)
    if (pts.length){
      let minX=+Infinity,minY=+Infinity,maxX=-Infinity,maxY=-Infinity;
      for (const [x,y] of pts){ minX=Math.min(minX,x); minY=Math.min(minY,y); maxX=Math.max(maxX,x); maxY=Math.max(maxY,y); }
      const w=(maxX-minX)*S, d=(maxY-minY)*S;
      const floor = new THREE.Mesh(new THREE.BoxGeometry(w+0.4, 0.02, d+0.4), materials.floor);
      const c = to3((minX+maxX)/2,(minY+maxY)/2);
      floor.position.set(c.x, -0.01, c.z);
      currentGroup.add(floor);
    }

    // Index openings by “owning” wall (projection-based)
    function projectT(ax,ay,bx,by, px,py){
      const vx=bx-ax, vy=by-ay; const L2=vx*vx+vy*vy;
      if (L2===0) return 0;
      const L = Math.sqrt(L2);
      return Math.max(0, Math.min(L, ((px-ax)*vx + (py-ay)*vy)/L ));
    }

    for (const w of plan.walls){
      // Wall vector & helpers in SVG space
      const ax=w.x1, ay=w.y1, bx=w.x2, by=w.y2;
      const vx=bx-ax, vy=by-ay;
      const Lsvg = Math.hypot(vx,vy);
      if (Lsvg<0.0001) continue;
      const ux=vx/Lsvg, uy=by-ay; // BUG FIX: earlier wrong; correct below
      // correct unit vector
      const ux_norm = (bx-ax)/Lsvg;
      const uy_norm = (by-ay)/Lsvg;

      // Gather openings near this wall
      const along = [];
      function consider(open, type){
        const cx=(open.x1+open.x2)/2, cy=(open.y1+open.y2)/2;
        const dist = Math.abs((vy)*(cx-ax) - (vx)*(cy-ay))/Lsvg;
        if (dist<=2.0){
          const t = projectT(ax,ay,bx,by,cx,cy);
          const half = (open.width/2);
          along.push({ type, start: Math.max(0, t-half), end: Math.min(Lsvg, t+half) });
        }
      }
      plan.doors.forEach(d => consider(d, 'door'));
      plan.wins.forEach (w2 => consider(w2, 'window'));
      along.sort((a,b)=>a.start-b.start);

      // Merge overlaps
      const merged=[];
      for (const seg of along){
        if (!merged.length || seg.start > merged[merged.length-1].end){
          merged.push({...seg});
        } else {
          const top=merged[merged.length-1];
          top.end = Math.max(top.end, seg.end);
          if (seg.type==='door') top.type='door';
        }
      }

      // Build wall segments (full height)
      const thicknessM = (w.thicknessMM / 1000);
      const wallH = cfg.wallH;
      const segments=[];
      let cursor=0;
      for (const hole of merged){
        if (hole.start>cursor) segments.push([cursor, hole.start]);
        cursor = hole.end;
      }
      if (cursor<Lsvg) segments.push([cursor, Lsvg]);

      function addLongBox(s0, s1, h, y0=0){
        const lenSVG = Math.max(0, s1-s0);
        if (lenSVG<=0.0001) return;
        const lenM = lenSVG * S;
        const geom = new THREE.BoxGeometry(lenM, h, thicknessM);
        const mesh = new THREE.Mesh(geom, materials.wall);
        const midSVGx = ax + ux_norm*(s0 + lenSVG/2);
        const midSVGy = ay + uy_norm*(s0 + lenSVG/2);
        const pos = to3(midSVGx, midSVGy);
        mesh.position.set(pos.x, y0 + h/2, pos.z);
        const angle = Math.atan2(uy_norm, ux_norm);
        mesh.rotation.y = -angle;
        currentGroup.add(mesh);
      }

      for (const [s0,s1] of segments){
        addLongBox(s0, s1, wallH, 0);
      }

      const doorH = cfg.doorH;
      const sillH = cfg.sillH;
      const winH  = cfg.winH;
      for (const hole of merged){
        const s0 = hole.start, s1 = hole.end;
        if (hole.type==='door'){
          if (doorH<wallH) addLongBox(s0, s1, wallH-doorH, doorH);
          const lenM=(s1-s0)*S;
          const geom=new THREE.BoxGeometry(lenM, doorH*0.98, thicknessM*0.1);
          const m=new THREE.Mesh(geom, materials.door);
          const midSVGx = ax + ux_norm*((s0+s1)/2);
          const midSVGy = ay + uy_norm*((s0+s1)/2);
          const pos = to3(midSVGx, midSVGy);
          m.position.set(pos.x, doorH/2, pos.z);
          m.rotation.y = -Math.atan2(uy_norm,ux_norm);
          currentGroup.add(m);
        } else {
          if (sillH>0) addLongBox(s0, s1, Math.min(sillH, wallH), 0);
          const topY = sillH + winH;
          if (topY<wallH) addLongBox(s0, s1, wallH - topY, topY);
          const lenM=(s1-s0)*S;
          const pane = new THREE.Mesh(new THREE.BoxGeometry(lenM, winH*0.98, Math.max(0.01, thicknessM*0.1)), materials.glass);
          const midSVGx = ax + ux_norm*((s0+s1)/2);
          const midSVGy = ay + uy_norm*((s0+s1)/2);
          const pos = to3(midSVGx, midSVGy);
          pane.position.set(pos.x, sillH + winH/2, pos.z);
          pane.rotation.y = -Math.atan2(uy_norm,ux_norm);
          currentGroup.add(pane);
        }
      }
    }

    fitCameraToObject(currentGroup, 1.4);
    statusEl.textContent = 'Modello pronto';
    metaEl.textContent = `Pareti: ${plan.walls.length} · Porte: ${plan.doors.length} · Finestre: ${plan.wins.length}`;
  }

  function fitCameraToObject(obj, mult=1.2){
    const box = new THREE.Box3().setFromObject(obj);
    const size = new THREE.Vector3(); box.getSize(size);
    const center = new THREE.Vector3(); box.getCenter(center);
    const maxDim = Math.max(size.x, size.y, size.z);
    const dist = (maxDim / Math.tan(THREE.MathUtils.degToRad(camera.fov*0.5))) * mult;

    const dir = new THREE.Vector3(1,0.6,1).normalize();
    const newPos = center.clone().add(dir.multiplyScalar(dist));
    camera.position.copy(newPos);
    camera.near = Math.max(0.1, dist/100);
    camera.far  = dist*10 + maxDim*2;
    camera.updateProjectionMatrix();
    orbit.target.copy(center);
    orbit.update();
  }

  // ---------- File handling ----------
  fileEl.addEventListener('change', async e=>{
    const f = e.target.files?.[0];
    if (!f) return;
    statusEl.textContent='Caricamento...';
    const txt = await f.text();
    try{
      const plan = svgToPlan(txt);
      build3D(plan, currentConfig());
    }catch(err){
      console.error(err);
      statusEl.textContent='Errore nel parsing SVG';
    }
  });

  resetBtn.addEventListener('click', ()=>{
    if (currentGroup) fitCameraToObject(currentGroup, 1.3);
  });

  // Demo SVG — unità: millimetri
  const demoSVG = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 7000 5000">
  <!-- Pareti perimetrali -->
  <line class="wall" data-thickness="120" x1="500" y1="500" x2="6500" y2="500" />
  <line class="wall" data-thickness="120" x1="6500" y1="500" x2="6500" y2="4500" />
  <line class="wall" data-thickness="120" x1="6500" y1="4500" x2="500"  y2="4500" />
  <line class="wall" data-thickness="120" x1="500"  y1="4500" x2="500"  y2="500" />
  <!-- Tramezza centrale -->
  <line class="wall" data-thickness="100" x1="3500" y1="500" x2="3500" y2="4500" />
  <!-- Porta sulla tramezza -->
  <line class="door" x1="3500" y1="2500" x2="3500" y2="2700" />
  <!-- Porta esterna -->
  <line class="door" x1="2000" y1="4500" x2="2400" y2="4500" />
  <!-- Finestra esterna -->
  <line class="window" x1="5000" y1="500" x2="5600" y2="500" />
</svg>`.trim();

  demoBtn.addEventListener('click', ()=>{
    statusEl.textContent='Carico demo...';
    const plan = svgToPlan(demoSVG);
    build3D(plan, currentConfig());
  });

  function currentConfig(){
    return {
      unitsPerMeter: parseFloat(unitsEl.value || '1000'),
      wallH: parseFloat(wallHEl.value || '2.8'),
      doorH: parseFloat(doorHEl.value || '2.1'),
      sillH: parseFloat(sillHEl.value || '0.9'),
      winH:  parseFloat(winHEl.value  || '1.2')
    };
  }

</script>
</body>
</html>
